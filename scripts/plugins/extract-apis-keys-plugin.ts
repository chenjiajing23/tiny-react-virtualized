import fs from 'fs';
import path from 'path';
import { Compiler, WebpackError } from 'webpack';

/** 提取 apis.tsx? 文件方法到 src/typings/apis-keys.d.ts 中 */
export interface WebpackApisKeyOptions {
  filename: string; // 要遍历的文件名,默认：'apis'
  outputPath: string, // 文件输出路径,默认: '/src/types/apis-keys.d.ts'
  requireContext: string[]; // 匹配路径，默认：['/src/modules']
}

export class ExtractApisKeysPlugin {
  private options: WebpackApisKeyOptions = {
    filename: 'apis',
    outputPath: '/src/typings/apis-keys.d.ts',
    requireContext: ['/src/modules', '/src/components'].map(item => process.cwd() + item)
  };

  constructor(readonly params?: Partial<WebpackApisKeyOptions>) {
    const isObject = params !== null && (typeof params === 'object' || typeof params === 'function');
    if (params) {
      if (!isObject) {
        throw new TypeError('Option item must be object!');
      } else {
        this.options = Object.assign(this.options, params);
      }
    }
  }

  public apply(compiler: Compiler): void {
    compiler.hooks.emit.tapAsync('ExtractApisKeysPlugin', (compilation, callback) => {
      // 获取项目根目录
      const context = compiler.context;
      const outputPath = path.join(context, this.options.outputPath);
      // 缓存apis {key: url} 值
      let apis: { key: string, url: string }[] = [];

      compilation.chunks.forEach(chunk => {
        compilation.chunkGraph?.getChunkModules(chunk).forEach(module => {
          try {
            // 例：输入：['/src/modules', '/src/pages']  输出 -> ((\/src\/modules)|(\/src\/pages))
            const requireContext = this.options.requireContext.map(item => `(${item.replace(/\//g, "\\/")})`).join("|");
            // 正则：匹配对应目录下的文件，例：./src/modules/login/apis.ts
            const Regex = RegExp(`(${requireContext})[\\w-\\/]*\\/${this.options.filename}\\.ts(x?)$`);
            const filePath = String((module as any).resource);

            if (Regex.test(filePath)) {
              const sourceContent = (module as any)._source._sourceMapAsObject.sourcesContent[0] as string;
              const apisAry = sourceContent.match(/[\w-]+(?=\s*\:\s*\{)/g); // 零宽断言匹配 " : { " 前面的字符串
              if (apisAry) {
                apis.push(...apisAry.map(key => ({ key, url: filePath })));
              }
            }
          } catch (error) {
            // console.error(error);
          }
        });

        // Explore each asset filename generated by the chunk:
        // chunk.files.forEach((filename) => {
        //   const source = compilation.assets[filename].source();
        // });
      });

      // key 重复判断
      const res = []; // 去重后key值数组
      const obj: { [key: string]: any } = {};
      for (let i = 0; i < apis.length; i++) {
        const key = apis[i].key;
        const url = apis[i].url;
        if (!obj[key]) {
          obj[key] = url;
          res.push(apis[i]);
        } else {
          compilation.errors.push(
            new WebpackError(
              `\n extract-apis-webpack-plugin \n\n` +
              `${obj[key]} \n` +
              `${url} \n` +
              `\n '${key}'重复定义了！\n`
            )
          );
        }
      }

      if (res.length !== 0) {
        // 生成字符串
        const insertContent = `declare const keys: [${res.map(item => `'${item.key}'`)}];`;
        // 异步写入文件
        fs.writeFile(outputPath, insertContent, err => {
          if (err) {
            const errMessage = "\nextract-apis-webpack-plugin 输出文件失败 \n" + err;
            compilation.errors.push(new WebpackError(errMessage));
          }
        });
      } else {
        console.warn(`
          extract-apis-webpack-plugin warning :
          没有匹配到api配置项，请检查
        `);
      }
      callback();
    });
  }
}

export default ExtractApisKeysPlugin;
